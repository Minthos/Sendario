
<!-- saved from url=(0190)https://webcache.googleusercontent.com/search?q=cache:6XB6RH7eMCgJ:https://www.gamedev.net/blog/73/entry-2006307-tip-of-the-day-logarithmic-zbuffer-artifacts-fix/&hl=en&gl=no&strip=1&vwsrc=0 -->
<html lang="en">
<b>Logarithmic zbuffer artifacts fix</b><br><br>In cameni's <a href="https://www.gamedev.net/community/forums/mod/journal/journal.asp?jn=503094">Journal of Lethargic Programmers</a>, I've been very interested by his idea about using a logarithmic zbuffer.<br><br>Unfortunately, his idea comes with a couple of very annoying artifacts, due to the linear interpolation of the logarithm (non-linear) based formula. It particularly shows on thin or huge triangles where one or more vertices fall off the edges of the screen. As cameni explains himself in his journal, basically for negative Z values, the triangles tend to pop in/out randomly.<br><br>It was suggested to keep a high tesselation of the scene to avoid the problem, or to use geometry shaders to automatically tesselate the geometry.<br><br>I'm proposing a solution that is much more simple and that works on pixel shaders 2.0+: simply generate the correct Z value at the pixel shader level.<br><br>In the vertex shader, just use an interpolator to pass the vertex position in clip space (GLSL) (here I'm using tex coord interpolator #6):<br><br><pre>void main(){  vec4 vertexPosClip = gl_ModelViewProjectionMatrix * gl_Vertex;  gl_Position = vertexPosClip;  gl_TexCoord[6] = vertexPosClip;}</pre><br>Then you override the depth value in the pixel shader:<br><br><pre>void main(){  gl_FragColor = ...  const float C = 1.0;  const float far = 1000000000.0;  const float offset = 1.0;  gl_FragDepth = (log(C * gl_TexCoord[6].z + offset) / log(C * far + offset));}</pre><br>Note that as cameni indicated before, the 1/log(C*far+1.0) can be optimized as a constant. You're only really paying the price for a mad and a log.<br><br>Quality-wise, I've found that solution to work perfectly: no artifacts at all. In fact, I went so far as testing a city with centimeter to meter details seen from thousands of kilometers away using a very very small field-of-view to simulate zooming. I'm amazed by the quality I got. It's almost magical. ZBuffer precision problems will become a thing of the past, even when using large scales such as needed for a planetary engine.<br><br>There's a performance hit due to the fact that fast-Z is disabled, but to be honnest in my tests I haven't seen a difference in the framerate. Plus, tesselating the scene more or using geometry shaders would very likely cost even more performance than that.<br><br>I've also found that to control the znear clipping and reduce/remove it, you simply have to adjust the "offset" constant in the code above. Cameni used a value of 1.0, but with a value of 2.0 in my setup scene, it moved the znear clipping to a few centimeters.<br><br><b>Results</b><br><br>Settings of the test:<br>- znear = 1.0 inch<br>- zfar = 39370.0 * 100000.0 inches = 100K kilometers<br>- camera is at 205 kilometers from the scene and uses a field-of-view of 0.01?<br>- zbuffer = 24 bits<br><br>Normal zbuffer:<br><a href="http://www.infinity-universe.com/Infinity/Media/Misc/zbufflogoff.jpg"><br>http://www.infinity-universe.com/Infinity/Media/Misc/zbufflogoff.jpg</a><br><br>Logarithmic zbuffer:<br><a href="http://www.infinity-universe.com/Infinity/Media/Misc/zbufflogon.jpg">http://www.infinity-universe.com/Infinity/Media/Misc/zbufflogon.jpg</a><br><br><b>Future works</b><br><br>Could that trick be used to increase precision of shadow maps ?
</html>
